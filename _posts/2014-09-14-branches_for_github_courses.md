---
layout: post
title: "Как делать ветки в своем форке"
date: 2014-06-27 22:20
author: dummer
categories: manuals
---

В pull request в github попадает **вся разница** между веткой в нашем форке и веткой в исходном репозитории. Поэтому, если мы будем делать всю свою работу в основной ветке, то при отправке на проверку нашего решения отправятся в том числе и уже проверенные файлы. Для того, чтобы избежать этого мы будем применять ветвление. В git от любого коммита может идти несколько веток. ... Меньше слов.

0. Дабы что-нибудь случайно не потерять в процессе, рекомендуется сохранить свои файлы из репозитория на время где-нибудь еще.
1. Для начала нам нужно сделать ветку, которая будет синхронизированна с исходным репозиторием и не будет содержать наших коммитов. Выполнив команду `git log` мы увидим историю изменений от нашего последнего коммита (сейчас на нашем находится указатель HEAD) до корня дерева коммитов. Промотаем её до конца. Нас интересует самый первый коммит, который имеет хэш `69b20d09...`. Переместим HEAD на него командой `git checkout 69b20d`. Git нам сообщит, что мы находимся в состоянии 'detached HEAD'. Это означает, что сейчас указатель HEAD указывает на коммит на который не указывает ни один из символических указателей (тега или ветки), в этом обычно нет ничего страшного. А еще в том же сообщении git подсказывает нам действия для создания новой ветки от этого коммита. Выполним `git checkout -b tasks`. После этого создастся ветка *tasks* и мы переместимся в неё (имя текущей ветки обычно пишется в скобках в приглашении к вводу).
2. Теперь нам нужно в созданную ветку поместить все коммиты из исходного репозитория. Делаем так же, как мы делали работая в одной ветке: `git pull upstream master`. Выполнив `git log` мы обнаружим, что история коммитов совпадает с историей исходного репозитория, состояние файлов тоже целиком соответствует текущему состоянию файлов в исходном репозитории.
3. Теперь условимся о следующем порядке работы:
	1. Приступая к работе над очередным заданием мы сначала переключаемся на ветку *tasks*: `git checkout tasks`. 
	2. Синхронизируем эту ветку с исходным репозиторием: `git pull upstream master`.
	3. Создаем ветку в которой будем выполнять работу над заданием: `git checkout -b <имя ветки>`, где `<имя ветки>`, например это `class-02`. Имена веток должны быть уникальными и, желательно, говорящими о содержании.
	4. В этой ветке делаем всю работу, создавая необходимое для этого число коммитов.
	5. Отправляем нашу работу в ветке на сервер: `git push origin <имя ветки>`.
	6. Теперь для создания pull request'а на github нужно выбрать из выпадающего списка нужную ветку.


### Ссылки для чуть более подробного разбора:

* [Что такое ветка?](http://git-scm.com/book/ru/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%3F)
* [Основы ветвления и слияния](http://git-scm.com/book/ru/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F)
* [Удалённые ветки](http://git-scm.com/book/ru/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%A3%D0%B4%D0%B0%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2%D0%B5%D1%82%D0%BA%D0%B8)
